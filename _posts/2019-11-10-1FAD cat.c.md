---
layout: post
title: OpenBSD - 1 file a day (cat.c)
categories: [1fad]
tags: [programming]
lang: en
---

A few years ago I've read about looking at and understanding one source
file of the OpenBSD operating system a day. And since then I've always
wanted to start with it. Though I've only got to the first file, since
then. Because I don't have much free time to devote to this activity, I
highly doubt it's possible to satisfy the given interval at reading and
understanding. Nevertheless, I want to share my discoveries with you and
show you some (not all, hopefully) files I deemed as interesting and
worthy to describe in depth. So I thought why don't give this a little
motivation bump and write about it in my blog. The given title 1fad stands for
1 file a day.


To begin with I want to focus my view on cat.c.
## Overview
Cat is a program everyone using a linux or mac operating system should
know about, after a few days of working with the os. It's derived from
the word concatenate and is used to add the contents of files together
and output it on the standart output. As simple as it's function sounds,
the source file is (license included) 249 SLOC long. Also it's making
use of helper functions out of ten header files.
## Header files
This is the list of the header files I mentioned above:
```c
#include <sys/types.h>
#include <sys/stat.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
```
### types.h
The file types.h defines extra types for variables. The only usage of
types out of this header file is `size_t` and `ssize_t`. According to
the NetBSD-8.1 man page for
[types](https://man.openbsd.org/NetBSD-8.1/types), `size_t` is typically
used for size declaration of objects and `ssize_t` is used for counting
of bytes. Usually these two are defined like this (depending on your
architecture):
```c
typedef unsigned long __size_t;
typedef long __ssize_t;
```
### stat.h
With the functions, variables and structs defined in stat.h you are able
to retrieve information from various files. In cat.c `int fstat(int,
struct stat *);` is used to copy information about the standard
outstream (passed as a file descriptor) into a stat struct. The stat
struct (big surprise) is also defined in stat.h and inhabits all
important data about files. Out of this struct only `st_blksize` is
used. This variable states _"the optimal I/O block size for the file"_
([stat(2)](https://man.openbsd.org/fstat.2)).
### ctype.h
The source code uses functions out of this header file to check if the given
char is a printable, or an invisible control character. You can achieve this
behaviour with the v flag ([cat(1)](https://man.openbsd.org/cat)).
The two functions used are `__only_inline int isascii(int _c)` and 
`__only_inline int iscntrl(int _c)`. Furthermore there is
`__only_inline int toascii(int _c)` to convert any given char into an ascii 
value. Before I take a look at both definitions of these functions, I want to
shine some (really not much) light on the declaration. You may notice that 
there is a special keyword before int. Defined in 
[cdefs.h](https://github.com/openbsd/src/blob/master/sys/sys/cdefs.h) it
manages inlining of functions. The comment in the source file describes it
best:
```c
/*
 * __only_inline makes the compiler only use this function definition
 * for inlining; references that can't be inlined will be left as
 * external references instead of generating a local copy. The
 * matching library should include a simple extern definition for
 * the function to handle those references. c.f. ctype.h
 */
```
In general, inlining of extern or static functions has something to do with
optimization. The definition of all three mentioned functions are very simple
oneliners. In my opinion the less interesting one is
`__only_inline int toascii(int _c)`.
```c
__only_inline int toascii(int _c)
{
  return (_c & 0177);
}
```
As you pass any char value to this function it converts it to an integer value
(because of `int _c`). Afterwards it applies the variable with a bitwise AND
operation to the octal value 0177 (that's the last value of the ascii table).
With this you can expect that the given parameter is always in the range of the
ascii table. `__only_inline int toascii(int_c)` works with the same method in
mind. _"The isascii() function returns zero if the character tests false or 
non-zero if the character tests true."_
([isascii(3)](https://man.openbsd.org/isascii.3)). The man page also states: _"
The isascii() function tests for an ASCII character, wich is any character with
a value less than or equal to 0177."_.
The function definition of iscntrl makes an interesting use of a pointer
assignment to a char array with the field size of the integer value of it.
```c
//...
#define _C 0x20
extern const char *_ctype_;
//...
__only_inline int iscntrl(int _c)
{
  return (_c == -1 ? 0 : ((_ctype_ + 1)[(unsigned char)_c] & _C));
}
```
The most interesting part is `(_ctype_ + 1)[(unsigned char)_c]`. As I've
already dug deeper into this header file than I initially wanted, I'll not go
into it any further and let this function abide marked as interesting. (Also
because I don't understand how this works yet, after a few days of puzzling.)
